<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>D&D Map Utility</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: Arial, sans-serif;
            background-color: #2c2c2c;
            color: white;
        }

        .controls {
            margin-bottom: 20px;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        button {
            padding: 10px 20px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
        }

        button:hover {
            background-color: #45a049;
        }

        button:disabled {
            background-color: #666;
            cursor: not-allowed;
        }

        #fileInput {
            display: none;
        }

        .map-container {
            position: relative;
            border: 2px solid #666;
            background-color: #1a1a1a;
            max-width: 100%;
            max-height: 80vh;
            overflow: hidden;
        }

        #mapImage {
            display: block;
            max-width: 100%;
            max-height: 80vh;
            object-fit: contain;
            position: relative;
            z-index: 1;
        }

        #mapImage.interaction-disabled {
            pointer-events: none;
        }

        #wallCanvas, #fogCanvas {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
            z-index: 2;
        }

        #wallCanvas.editing {
            pointer-events: all;
            cursor: crosshair;
            z-index: 3;
        }

        #fogCanvas.playing {
            pointer-events: all;
            z-index: 3;
        }

        .status {
            margin-top: 10px;
            padding: 10px;
            background-color: #333;
            border-radius: 5px;
        }
    </style>
</head>
<body>
    <h1>D&D Map Utility</h1>
    
    <div class="controls">
        <input type="file" id="fileInput" accept="image/*">
        <button id="chooseMapBtn">Choose Local Map File</button>
        <button id="editWallsBtn" disabled>Edit Walls</button>
        <button id="playGameBtn" disabled>Play Game</button>
    </div>

    <div class="map-container" id="mapContainer" style="display: none;">
        <img id="mapImage" alt="D&D Map">
        <canvas id="wallCanvas"></canvas>
        <canvas id="fogCanvas"></canvas>
    </div>

    <div class="status" id="status">
        Select a map file to begin.
    </div>

    <script>
        // Global variables
        let mapImage = null;
        let wallCanvas = null;
        let wallCtx = null;
        let fogCanvas = null;
        let fogCtx = null;
        
        // Game state
        let currentMode = 'view'; // 'view', 'editWalls', 'playGame'
        let walls = []; // Array of wall objects, each with vertices array
        let currentWall = null; // Wall being created
        let playerCharacters = [];
        let npcs = [];
        let selectedVertex = null;
        let isDragging = false;
        let dragOffset = { x: 0, y: 0 };
        
        // Constants - adjustable via browser console
        window.SIGHT_RADIUS = 15; // feet - change this value in browser console: SIGHT_RADIUS = 30
        let SIGHT_RADIUS = window.SIGHT_RADIUS;
        let GRID_SIZE = 5; // pixels per foot (will be calculated based on map)
        
        // DOM elements
        const fileInput = document.getElementById('fileInput');
        const chooseMapBtn = document.getElementById('chooseMapBtn');
        const editWallsBtn = document.getElementById('editWallsBtn');
        const playGameBtn = document.getElementById('playGameBtn');
        const mapContainer = document.getElementById('mapContainer');
        const mapImg = document.getElementById('mapImage');
        const status = document.getElementById('status');
        
        // Initialize
        init();
        
        function init() {
            wallCanvas = document.getElementById('wallCanvas');
            wallCtx = wallCanvas.getContext('2d');
            fogCanvas = document.getElementById('fogCanvas');
            fogCtx = fogCanvas.getContext('2d');
            
            // Event listeners
            chooseMapBtn.addEventListener('click', () => fileInput.click());
            fileInput.addEventListener('change', handleMapUpload);
            editWallsBtn.addEventListener('click', toggleWallEditMode);
            playGameBtn.addEventListener('click', startPlayMode);
            
            // Canvas event listeners
            wallCanvas.addEventListener('click', handleWallCanvasClick);
            wallCanvas.addEventListener('dblclick', handleWallCanvasDoubleClick);
            wallCanvas.addEventListener('mousedown', handleMouseDown);
            wallCanvas.addEventListener('mousemove', handleMouseMove);
            wallCanvas.addEventListener('mouseup', handleMouseUp);
            
            fogCanvas.addEventListener('click', handleFogCanvasClick);
            fogCanvas.addEventListener('dblclick', handleFogCanvasDoubleClick);
            fogCanvas.addEventListener('mousedown', handleFogMouseDown);
            fogCanvas.addEventListener('mousemove', handleFogMouseMove);
            
            // Add triple-click support
            let tripleClickTimer = null;
            let tripleClickCount = 0;
            fogCanvas.addEventListener('click', (event) => {
                tripleClickCount++;
                if (tripleClickTimer) {
                    clearTimeout(tripleClickTimer);
                }
                tripleClickTimer = setTimeout(() => {
                    tripleClickCount = 0;
                }, 500);
            });
            
            // Keyboard events
            document.addEventListener('keydown', handleKeyDown);
        }
        
        function handleMapUpload(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            if (!file.type.startsWith('image/')) {
                updateStatus('Please select a valid image file.');
                return;
            }
            
            const reader = new FileReader();
            reader.onload = function(e) {
                mapImg.src = e.target.result;
                mapImg.onload = function() {
                    // Show the container first so the image gets laid out
                    mapContainer.style.display = 'block';
                    
                    // Use setTimeout to ensure the image is laid out before sizing canvases
                    setTimeout(() => {
                        setupCanvases();
                        editWallsBtn.disabled = false;
                        playGameBtn.disabled = false;
                        updateStatus('Map loaded successfully. You can now edit walls or start playing.');
                        
                        // Reset game state
                        walls = [];
                        currentWall = null;
                        playerCharacters = [];
                        npcs = [];
                        selectedVertex = null;
                        currentMode = 'view';
                        
                        // Update button states
                        editWallsBtn.textContent = 'Edit Walls';
                        wallCanvas.classList.remove('editing');
                        fogCanvas.classList.remove('playing');
                        mapImg.classList.remove('interaction-disabled');
                    }, 0);
                };
            };
            reader.readAsDataURL(file);
        }
        
        function setupCanvases() {
            const rect = mapImg.getBoundingClientRect();
            const imgWidth = mapImg.naturalWidth;
            const imgHeight = mapImg.naturalHeight;
            const displayWidth = mapImg.offsetWidth;
            const displayHeight = mapImg.offsetHeight;
            
            console.log('Setup canvases - displayWidth:', displayWidth, 'displayHeight:', displayHeight);
            
            // Ensure we have valid dimensions
            if (displayWidth === 0 || displayHeight === 0) {
                console.error('Canvas dimensions are 0! Image may not be laid out yet.');
                return;
            }
            
            // Set canvas dimensions to match displayed image
            wallCanvas.width = displayWidth;
            wallCanvas.height = displayHeight;
            fogCanvas.width = displayWidth;
            fogCanvas.height = displayHeight;
            
            // Calculate grid size (assume map is roughly 50x50 feet for now)
            GRID_SIZE = Math.min(displayWidth / 50, displayHeight / 50);
            
            console.log('Canvas setup complete - width:', displayWidth, 'height:', displayHeight, 'grid size:', GRID_SIZE);
            
            clearCanvas(wallCtx);
            clearCanvas(fogCtx);
            drawWalls();
        }
        
        function clearCanvas(ctx) {
            ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
        }
        
        function updateStatus(message) {
            status.textContent = message;
        }
        
        function toggleWallEditMode() {
            if (currentMode === 'editWalls') {
                // Exit wall editing mode
                currentMode = 'view';
                editWallsBtn.textContent = 'Edit Walls';
                wallCanvas.classList.remove('editing');
                mapImg.classList.remove('interaction-disabled');
                currentWall = null;
                selectedVertex = null;
                updateStatus('Exited wall editing mode. Map is now in view mode.');
            } else {
                // Enter wall editing mode
                currentMode = 'editWalls';
                editWallsBtn.textContent = 'Stop Editing Walls';
                wallCanvas.classList.add('editing');
                fogCanvas.classList.remove('playing');
                mapImg.classList.add('interaction-disabled');
                updateStatus('Wall editing mode - click to place vertices, double-click to finish wall, click vertex + delete to remove wall');
            }
        }
        
        function startPlayMode() {
            currentMode = 'playGame';
            editWallsBtn.textContent = 'Edit Walls';
            wallCanvas.classList.remove('editing');
            fogCanvas.classList.add('playing');
            mapImg.classList.add('interaction-disabled');
            currentWall = null;
            selectedVertex = null;
            
            // Initialize fog
            initializeFog();
            startFogAnimation();
            
            updateStatus('Play mode - click to spawn/move PCs, double-click for new PC, triple-click for NPC');
        }
        
        function initializeFog() {
            clearCanvas(fogCtx);
            
            // Create animated fog pattern
            const width = fogCanvas.width;
            const height = fogCanvas.height;
            
            // Fill entire canvas with opaque fog
            fogCtx.fillStyle = '#4a4a4a';
            fogCtx.globalAlpha = 1.0;
            fogCtx.fillRect(0, 0, width, height);
            
            // Clear areas around existing PCs
            playerCharacters.forEach(pc => {
                clearFogAroundPosition(pc.x, pc.y, window.SIGHT_RADIUS * GRID_SIZE, true);
            });
            
            // Draw characters on top
            drawCharacters();
        }
        
        let fogAnimationId;
        
        let baseFogCanvas = null; // Store the base fog without animation
        
        function startFogAnimation() {
            if (fogAnimationId) {
                cancelAnimationFrame(fogAnimationId);
            }
            
            // Create a copy of the current fog state for the base
            baseFogCanvas = document.createElement('canvas');
            baseFogCanvas.width = fogCanvas.width;
            baseFogCanvas.height = fogCanvas.height;
            const baseFogCtx = baseFogCanvas.getContext('2d');
            baseFogCtx.drawImage(fogCanvas, 0, 0);
            
            function animateFog() {
                if (currentMode === 'playGame') {
                    // Restore base fog
                    fogCtx.clearRect(0, 0, fogCanvas.width, fogCanvas.height);
                    fogCtx.drawImage(baseFogCanvas, 0, 0);
                    
                    // Add very subtle shimmer effect
                    const time = Date.now() * 0.0008;
                    fogCtx.save();
                    fogCtx.globalAlpha = 0.03;
                    
                    // Simple gradient shimmer
                    const gradient = fogCtx.createLinearGradient(0, 0, fogCanvas.width, fogCanvas.height);
                    const shimmerOffset = Math.sin(time) * 0.1;
                    gradient.addColorStop(0, '#666666');
                    gradient.addColorStop(0.5 + shimmerOffset, '#777777');
                    gradient.addColorStop(1, '#555555');
                    
                    fogCtx.fillStyle = gradient;
                    fogCtx.fillRect(0, 0, fogCanvas.width, fogCanvas.height);
                    fogCtx.restore();
                    
                    // Redraw characters on top
                    drawCharacters();
                    
                    fogAnimationId = requestAnimationFrame(animateFog);
                }
            }
            
            animateFog();
        }
        
        function updateBaseFog() {
            // Update the base fog when permanent changes are made
            if (baseFogCanvas && currentMode === 'playGame') {
                const baseFogCtx = baseFogCanvas.getContext('2d');
                baseFogCtx.clearRect(0, 0, baseFogCanvas.width, baseFogCanvas.height);
                baseFogCtx.drawImage(fogCanvas, 0, 0);
            }
        }
        
        function clearFogAroundPosition(x, y, radius, permanent = true) {
            if (!permanent) {
                // Temporary clear for preview
                fogCtx.save();
                fogCtx.globalCompositeOperation = 'destination-out';
                fogCtx.beginPath();
                fogCtx.arc(x, y, radius, 0, 2 * Math.PI);
                fogCtx.fill();
                fogCtx.restore();
                return;
            }
            
            // Permanent clear with line-of-sight calculation
            const clearedPixels = new Set();
            
            // Cast rays in all directions
            const rayCount = 360;
            for (let angle = 0; angle < rayCount; angle++) {
                const radians = (angle * Math.PI) / 180;
                const dx = Math.cos(radians);
                const dy = Math.sin(radians);
                
                // Cast ray until it hits a wall or reaches max distance
                for (let distance = 0; distance <= radius; distance += 1) {
                    const rayX = x + dx * distance;
                    const rayY = y + dy * distance;
                    
                    // Check if ray hits a wall
                    if (isPositionBlockedByWall(x, y, rayX, rayY)) {
                        break;
                    }
                    
                    // Clear fog at this position
                    const pixelKey = `${Math.floor(rayX)},${Math.floor(rayY)}`;
                    if (!clearedPixels.has(pixelKey)) {
                        clearedPixels.add(pixelKey);
                        
                        fogCtx.save();
                        fogCtx.globalCompositeOperation = 'destination-out';
                        fogCtx.beginPath();
                        fogCtx.arc(rayX, rayY, 2, 0, 2 * Math.PI);
                        fogCtx.fill();
                        fogCtx.restore();
                    }
                }
            }
            
            // Update base fog if this was a permanent change
            if (permanent) {
                updateBaseFog();
            }
        }
        
        function handleWallCanvasClick(event) {
            if (currentMode !== 'editWalls') return;
            
            const rect = wallCanvas.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;
            
            // Check if clicking on an existing vertex
            const clickedVertex = findVertexAt(x, y);
            if (clickedVertex) {
                selectedVertex = clickedVertex;
                updateStatus('Vertex selected. Press Delete to remove wall, or drag to move.');
                return;
            }
            
            selectedVertex = null;
            
            // If no current wall, start a new one
            if (!currentWall) {
                currentWall = {
                    vertices: [{ x, y }],
                    id: Date.now()
                };
                drawWalls(); // Draw the first vertex
                updateStatus('Started new wall. Click to add more vertices, double-click to finish.');
            } else {
                // Add vertex to current wall
                currentWall.vertices.push({ x, y });
                drawWalls();
                updateStatus(`Wall has ${currentWall.vertices.length} vertices. Double-click to finish.`);
            }
        }
        
        function handleWallCanvasDoubleClick(event) {
            if (currentMode !== 'editWalls' || !currentWall) return;
            
            const rect = wallCanvas.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;
            
            // Add final vertex and complete the wall
            if (currentWall.vertices.length > 0) {
                currentWall.vertices.push({ x, y });
                walls.push(currentWall);
                currentWall = null;
                drawWalls();
                updateStatus('Wall completed. Click to start a new wall.');
            }
        }
        
        function handleMouseDown(event) {
            if (currentMode !== 'editWalls') return;
            
            const rect = wallCanvas.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;
            
            const clickedVertex = findVertexAt(x, y);
            if (clickedVertex) {
                selectedVertex = clickedVertex;
                isDragging = true;
                dragOffset = {
                    x: x - clickedVertex.x,
                    y: y - clickedVertex.y
                };
                wallCanvas.style.cursor = 'grabbing';
                event.preventDefault();
            }
        }
        
        function handleMouseMove(event) {
            if (currentMode !== 'editWalls') return;
            
            const rect = wallCanvas.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;
            
            if (isDragging && selectedVertex) {
                // Update vertex position
                selectedVertex.x = x - dragOffset.x;
                selectedVertex.y = y - dragOffset.y;
                
                // Redraw walls with updated position
                drawWalls();
                event.preventDefault();
            } else {
                // Update cursor based on whether we're hovering over a vertex
                const hoverVertex = findVertexAt(x, y);
                wallCanvas.style.cursor = hoverVertex ? 'grab' : 'crosshair';
            }
        }
        
        function handleMouseUp(event) {
            if (isDragging) {
                isDragging = false;
                dragOffset = { x: 0, y: 0 };
                wallCanvas.style.cursor = 'crosshair';
                updateStatus('Vertex moved. Click to select another vertex or continue adding walls.');
            }
        }
        
        let clickCount = 0;
        let clickTimer = null;
        let selectedPC = null;
        let isDraggingPC = false;
        let dragStartPos = { x: 0, y: 0 };
        
        function handleFogCanvasClick(event) {
            if (currentMode !== 'playGame') return;
            
            const rect = fogCanvas.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;
            
            clickCount++;
            
            if (clickTimer) {
                clearTimeout(clickTimer);
            }
            
            clickTimer = setTimeout(() => {
                if (clickCount === 1) {
                    handleSingleClick(x, y);
                } else if (clickCount === 2) {
                    handleDoubleClick(x, y);
                } else if (clickCount === 3) {
                    handleTripleClick(x, y);
                }
                clickCount = 0;
            }, 300);
        }
        
        function handleSingleClick(x, y) {
            // Check if clicking on existing PC
            const pc = findPCAt(x, y);
            if (pc) {
                selectedPC = pc;
                updateStatus(`PC selected. Drag to move, or click elsewhere to deselect.`);
            } else {
                selectedPC = null;
                updateStatus('No PC at this location. Double-click to create new PC, triple-click for NPC.');
            }
            drawCharacters();
        }
        
        function handleDoubleClick(x, y) {
            // Create new PC
            const newPC = {
                x: x,
                y: y,
                id: Date.now(),
                type: 'pc'
            };
            playerCharacters.push(newPC);
            selectedPC = newPC;
            
            // Clear fog around new PC
            clearFogAroundPosition(x, y, window.SIGHT_RADIUS * GRID_SIZE, true);
            
            drawCharacters();
            updateStatus(`New PC created. PCs can see ${window.SIGHT_RADIUS} feet around them.`);
        }
        
        function handleTripleClick(x, y) {
            // Create new NPC
            const newNPC = {
                x: x,
                y: y,
                id: Date.now(),
                type: 'npc'
            };
            npcs.push(newNPC);
            
            drawCharacters();
            updateStatus('New NPC created. NPCs do not affect fog.');
        }
        
        function handleFogCanvasDoubleClick(event) {
            // Prevent the double-click from being handled separately
            event.preventDefault();
        }
        
        function handleFogMouseDown(event) {
            if (currentMode !== 'playGame') return;
            
            const rect = fogCanvas.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;
            
            const pc = findPCAt(x, y);
            if (pc) {
                selectedPC = pc;
                isDraggingPC = true;
                dragStartPos = { x: pc.x, y: pc.y };
                fogCanvas.style.cursor = 'grabbing';
                
                // Add mousemove and mouseup listeners to document for better drag experience
                document.addEventListener('mousemove', handlePCDragMove);
                document.addEventListener('mouseup', handlePCDragEnd);
                
                event.preventDefault();
            }
        }
        
        function handlePCDragMove(event) {
            if (!isDraggingPC || !selectedPC) return;
            
            const rect = fogCanvas.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;
            
            // Update PC position
            selectedPC.x = x;
            selectedPC.y = y;
            
            // Clear fog around PC as it moves
            clearFogAroundPosition(x, y, window.SIGHT_RADIUS * GRID_SIZE, true);
            
            drawCharacters();
            event.preventDefault();
        }
        
        function handlePCDragEnd(event) {
            if (isDraggingPC) {
                isDraggingPC = false;
                fogCanvas.style.cursor = 'default';
                
                // Remove event listeners
                document.removeEventListener('mousemove', handlePCDragMove);
                document.removeEventListener('mouseup', handlePCDragEnd);
                
                updateStatus('PC moved. Fog has been cleared in their new line of sight.');
            }
        }
        
        function handleFogMouseMove(event) {
            if (currentMode !== 'playGame' || isDraggingPC) return;
            
            const rect = fogCanvas.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;
            
            const pc = findPCAt(x, y);
            fogCanvas.style.cursor = pc ? 'grab' : 'default';
        }
        
        function findPCAt(x, y, radius = 15) {
            for (const pc of playerCharacters) {
                const distance = Math.sqrt((x - pc.x) ** 2 + (y - pc.y) ** 2);
                if (distance <= radius) {
                    return pc;
                }
            }
            return null;
        }
        
        function drawCharacters() {
            // Draw characters directly on fog canvas
            fogCtx.save();
            
            // Draw PCs
            playerCharacters.forEach(pc => {
                drawCharacter(fogCtx, pc.x, pc.y, pc === selectedPC ? '#00ff00' : '#0066ff', 'PC');
            });
            
            // Draw NPCs
            npcs.forEach(npc => {
                drawCharacter(fogCtx, npc.x, npc.y, '#ff0000', 'NPC');
            });
            
            fogCtx.restore();
        }
        
        function drawCharacter(ctx, x, y, color, label) {
            ctx.fillStyle = color;
            ctx.strokeStyle = '#000000';
            ctx.lineWidth = 2;
            
            // Draw character circle
            ctx.beginPath();
            ctx.arc(x, y, 10, 0, 2 * Math.PI);
            ctx.fill();
            ctx.stroke();
            
            // Draw label
            ctx.fillStyle = '#ffffff';
            ctx.font = '10px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(label, x, y - 15);
            
            // Add black outline to text for visibility
            ctx.strokeStyle = '#000000';
            ctx.lineWidth = 1;
            ctx.strokeText(label, x, y - 15);
        }
        
        function handleKeyDown(event) {
            if (currentMode !== 'editWalls' || !selectedVertex) return;
            
            if (event.key === 'Delete' || event.key === 'Backspace') {
                const wall = findWallContainingVertex(selectedVertex);
                if (wall) {
                    // Remove the entire wall
                    if (wall === currentWall) {
                        currentWall = null;
                    } else {
                        const wallIndex = walls.indexOf(wall);
                        if (wallIndex > -1) {
                            walls.splice(wallIndex, 1);
                        }
                    }
                    
                    selectedVertex = null;
                    drawWalls();
                    updateStatus('Wall deleted. Continue editing or click to start a new wall.');
                }
                event.preventDefault();
            }
        }
        
        function drawWalls() {
            clearCanvas(wallCtx);
            
            // Draw completed walls
            walls.forEach(wall => {
                if (wall.vertices.length < 2) return;
                
                wallCtx.strokeStyle = '#ff0000';
                wallCtx.lineWidth = 3;
                wallCtx.beginPath();
                
                for (let i = 0; i < wall.vertices.length - 1; i++) {
                    const current = wall.vertices[i];
                    const next = wall.vertices[i + 1];
                    
                    if (i === 0) {
                        wallCtx.moveTo(current.x, current.y);
                    }
                    wallCtx.lineTo(next.x, next.y);
                }
                
                wallCtx.stroke();
                
                // Draw vertices
                wall.vertices.forEach(vertex => {
                    drawVertex(vertex, selectedVertex === vertex ? '#ffff00' : '#ff0000');
                });
            });
            
            // Draw current wall being created
            if (currentWall && currentWall.vertices.length > 0) {
                wallCtx.strokeStyle = '#ffaa00';
                wallCtx.lineWidth = 2;
                wallCtx.setLineDash([5, 5]);
                wallCtx.beginPath();
                
                for (let i = 0; i < currentWall.vertices.length - 1; i++) {
                    const current = currentWall.vertices[i];
                    const next = currentWall.vertices[i + 1];
                    
                    if (i === 0) {
                        wallCtx.moveTo(current.x, current.y);
                    }
                    wallCtx.lineTo(next.x, next.y);
                }
                
                wallCtx.stroke();
                wallCtx.setLineDash([]);
                
                // Draw vertices for current wall
                currentWall.vertices.forEach(vertex => {
                    drawVertex(vertex, '#ffaa00');
                });
            }
        }
        
        function drawVertex(vertex, color = '#ff0000') {
            wallCtx.fillStyle = color;
            wallCtx.beginPath();
            wallCtx.arc(vertex.x, vertex.y, 8, 0, 2 * Math.PI); // Increased from 5 to 8
            wallCtx.fill();
            
            // Add thick border for visibility
            wallCtx.strokeStyle = '#000000';
            wallCtx.lineWidth = 2; // Increased from 1 to 2
            wallCtx.stroke();
            
            // Add white inner circle for better contrast
            wallCtx.fillStyle = '#ffffff';
            wallCtx.beginPath();
            wallCtx.arc(vertex.x, vertex.y, 3, 0, 2 * Math.PI);
            wallCtx.fill();
        }
        
        function findVertexAt(x, y, radius = 15) {
            // Check current wall first
            if (currentWall) {
                for (const vertex of currentWall.vertices) {
                    const distance = Math.sqrt((x - vertex.x) ** 2 + (y - vertex.y) ** 2);
                    if (distance <= radius) {
                        return vertex;
                    }
                }
            }
            
            // Check completed walls
            for (const wall of walls) {
                for (const vertex of wall.vertices) {
                    const distance = Math.sqrt((x - vertex.x) ** 2 + (y - vertex.y) ** 2);
                    if (distance <= radius) {
                        return vertex;
                    }
                }
            }
            
            return null;
        }
        
        function findWallContainingVertex(targetVertex) {
            // Check current wall
            if (currentWall && currentWall.vertices.includes(targetVertex)) {
                return currentWall;
            }
            
            // Check completed walls
            return walls.find(wall => wall.vertices.includes(targetVertex));
        }
        
        function isPositionBlockedByWall(startX, startY, endX, endY) {
            // Check if line of sight from start to end position is blocked by any wall
            for (const wall of walls) {
                if (wall.vertices.length < 2) continue;
                
                // Check intersection with each wall segment
                for (let i = 0; i < wall.vertices.length - 1; i++) {
                    const wallStart = wall.vertices[i];
                    const wallEnd = wall.vertices[i + 1];
                    
                    if (lineIntersectsLine(startX, startY, endX, endY, wallStart.x, wallStart.y, wallEnd.x, wallEnd.y)) {
                        return true;
                    }
                }
            }
            return false;
        }
        
        function lineIntersectsLine(x1, y1, x2, y2, x3, y3, x4, y4) {
            // Calculate line intersection using parametric form
            const denom = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
            
            if (Math.abs(denom) < 1e-10) {
                // Lines are parallel
                return false;
            }
            
            const t = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / denom;
            const u = -((x1 - x2) * (y1 - y3) - (y1 - y2) * (x1 - x3)) / denom;
            
            // Check if intersection point is within both line segments
            return t >= 0 && t <= 1 && u >= 0 && u <= 1;
        }
    </script>
</body>
</html>